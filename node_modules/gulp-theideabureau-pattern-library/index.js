var through = require("through2"),
	isEmpty  = require("lodash.isempty"),
	path = require("path"),
	gutil = require("gulp-util"),
	changeCase = require('change-case');

module.exports = function (config) {
	"use strict";

	config = config || {};
	var origin = config.filename || "urls.json",
		firstFile,
		directoryStructure = {items: {}};

	function directoryMap(file, enc, callback) {
		/*jshint validthis:true*/

		if ( ! firstFile ) {
			firstFile = file;
		}

		// Do nothing if no contents
		if ( file.isNull() ) {
			this.emit("error", new gutil.PluginError("gulp-theideabureau-pattern-library", "File is null"));
			this.emit("end");
			return callback();
		}

		// No support for streams yet.
		if ( file.isStream() ) {
			this.emit("error", new gutil.PluginError("gulp-theideabureau-pattern-library", "No stream support!"));
			this.emit("end");
			return callback();
		}

		// But if it's a buffer...!
		if ( file.isBuffer() ) {

			var path = (config.prefix ? config.prefix + "/" : "") + file.path.replace(file.base, ""),
				segments = path.replace(/\\/g,"/").split("/"),
				parent = directoryStructure,
				breadcrumbs = [],
				breadcrumbUrls = [];

			segments.forEach(function(seg, index) {

				var filepath = seg.replace(/\\/g,"/"),
					name = filepath,
					order = 9999;

				name = name.replace(/.html$/gi, '').replace(/.json$/gi, '');

				// check if the name has a priority
				if ( name.match('^[0-9]+[.]') !== null ) {
					order = parseInt(name.split('.')[0]);
					name = name.substring(name.indexOf('.') + 1);
				}

				// keep a track of the breadcrumb urls
				breadcrumbUrls.push(name);

				// set file name case
				name = changeCase.title(name.replace(/-/g, ' '));

				// append this level to the breadcrumbs array
				breadcrumbs.push({
					url: breadcrumbUrls.join('/'),
					label: name,
				});

				// last item === file
				if ( index === segments.length -1 ) {

					var contents = file.contents.toString("utf-8");

					parent.items[seg] = {
						display: true,
						filepath: filepath,
						order: order,
						name: name,
						breadcrumbs: breadcrumbs,
						url: breadcrumbUrls.join('/'),
						contents: contents
					};

				} else {

					// either re-add the segment, or a blank object
					parent.items[seg] = parent.items[seg] || {
						display: true,
						order: order,
						name: name,
						// breadcrumbs: breadcrumbs,
						url: breadcrumbUrls.join('/'),
						items: {}
					};

					parent = parent.items[seg];

				}

			});

		}

		return callback();
	}

	function sortDirectoryMap(map) {

		// if an items object exists
		if ( typeof map.items !== "undefined" ) {

			var mapper = [],
				reorder = {};

			// convert the mapped items into an array format we can re-order
			Object.keys(map.items).forEach(function(key) {
				mapper.push([key, map.items[key].order]);
			});

			// order mapper items
			mapper.sort(function(a, b) {return a[1] - b[1]});

			// re-create the items object in the correct order
			mapper.forEach(function(value, key) {
				reorder[value[0]] = map.items[value[0]];
			});

			// re-apply the new object to the map items
			map.items = reorder;

			// recursively sort any sub-items
			Object.keys(map.items).forEach(function(key) {

				if ( typeof map.items[key].items !== "undefined" ) {
					map.items[key] = sortDirectoryMap(map.items[key]);
				}

			});

		}

		return map;

	}

	return through.obj(directoryMap,
		function(cb) {

			if ( isEmpty(directoryStructure) ) {
				this.emit("error", new gutil.PluginError("gulp-theideabureau-pattern-library", "No files found for directoryMap"));
				this.emit("end");
				return cb();
			}

			// sort the directory maps
			directoryStructure = sortDirectoryMap(directoryStructure);

			//create and push new vinyl file
			this.push(new gutil.File({
				cwd: firstFile.cwd,
				base: firstFile.cwd,
				path: path.join(firstFile.cwd, origin),
				contents: new Buffer(JSON.stringify(directoryStructure))
			}));

			gutil.log("Generated", gutil.colors.blue(config.filename));
			return cb();

		});
};
